// Code generated by etool. DO NOT EDIT.
// versions:
// - etool v0.0.3

package {{ .PackageName }}

import (
    "context"
    "errors"
    "fmt"
    "gorm.io/gorm"
	"strings"
)

type {{.TableName}}DaoImpl struct {
    db *gorm.DB
}

func (u *{{.TableName}}DaoImpl) Insert{{.TableName}}(ctx context.Context, {{.InstanceName}} *{{.TableName}}Model) error {
    return u.DB(ctx).WithContext(ctx).Create({{.InstanceName}}).Error
}

func (u *{{.TableName}}DaoImpl) BatchInsert{{.TableName}}s(ctx context.Context, {{.InstanceName}}s []*{{.TableName}}Model, batchSize int) error {
    return u.DB(ctx).WithContext(ctx).CreateInBatches({{.InstanceName}}s, batchSize).Error
}

func (u *{{.TableName}}DaoImpl) Delete{{.TableName}}ByID(ctx context.Context, id int64) error {
    return u.DB(ctx).WithContext(ctx).Delete(&{{.TableName}}Model{}, id).Error
}

func (u *{{.TableName}}DaoImpl) Delete{{.TableName}}s(ctx context.Context, filters map[string][]any) error {
    db := u.DB(ctx).WithContext(ctx).Model(&{{.TableName}}Model{})
    for query, args := range filters {
        count := strings.Count(query, "?")
        if count > 0 {
            if len(args) != count {
                return fmt.Errorf("filter: not enough args for key '%s'", query)
            }
            db = db.Where(query, args)
        } else {
            db = db.Where(query, args)
        }
    }
    return db.Delete(&{{.TableName}}Model{}).Error
}

func (u *{{.TableName}}DaoImpl) Update{{.TableName}}ByID(ctx context.Context, id int64, updates map[string]any) error {
    return u.DB(ctx).WithContext(ctx).Model(&{{.TableName}}Model{}).Where("id = ?", id).Updates(updates).Error
}

func (u *{{.TableName}}DaoImpl) Update{{.TableName}}s(ctx context.Context, filters map[string][]any, updates map[string]any) error {
    db := u.DB(ctx).WithContext(ctx).Model(&{{.TableName}}Model{})
    for query, args := range filters {
        count := strings.Count(query, "?")
        if count > 0 {
            if len(args) != count {
                return fmt.Errorf("filter: not enough args for key '%s'", query)
            }
            db = db.Where(query, args)
        } else {
            db = db.Where(query, args)
        }
    }
    return db.Updates(updates).Error
}

func (u *{{.TableName}}DaoImpl) Get{{.TableName}}ByID(ctx context.Context, id int64) ({{.InstanceName}} *{{.TableName}}Model, err error) {
    {{.InstanceName}} = &{{.TableName}}Model{}
    return {{.InstanceName}}, u.DB(ctx).WithContext(ctx).Where("id = ?", id).First({{.InstanceName}}).Error
}

func (u *{{.TableName}}DaoImpl) Get{{.TableName}}s(ctx context.Context, filters map[string][]any, offset, limit int) ({{.InstanceName}}s []*{{.TableName}}Model, total int64, err error) {
    {{.InstanceName}}s = make([]*{{.TableName}}Model, 0)
    db := u.DB(ctx).WithContext(ctx).Model(&{{.TableName}}Model{})
    for query, args := range filters {
        count := strings.Count(query, "?")
        if count > 0 {
            if len(args) != count {
                return {{.InstanceName}}s, total, fmt.Errorf("filter: not enough args for key '%s'", query)
            }
            db = db.Where(query, args)
        } else {
            db = db.Where(query, args)
        }
    }
    return {{.InstanceName}}s, total, db.Count(&total).Offset(offset).Limit(limit).Find(&{{.InstanceName}}s).Error
}

func (u *{{.TableName}}DaoImpl) Transaction(ctx context.Context, f func(ctx context.Context) error) error {
    return u.DB(ctx).Transaction(func(tx *gorm.DB) (err error) {
        defer func() {
            if r := recover(); r != nil {
                err = errors.New(fmt.Sprint(r))
            }
        }()
        ctx = context.WithValue(ctx, "tx", tx)
        return f(ctx)
    })
}

func (u *{{.TableName}}DaoImpl) DB(ctx context.Context) *gorm.DB {
    db := u.db
    if tx, exists := ctx.Value("tx").(*gorm.DB); exists {
        db = tx
    }
    return db
}

func New(db *gorm.DB) *{{.TableName}}DaoImpl {
    return &{{.TableName}}DaoImpl{db: db}
}

var _ {{.TableName}}Dao = (*{{.TableName}}DaoImpl)(nil)